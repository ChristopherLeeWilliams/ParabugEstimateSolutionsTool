<!DOCTYPE html>
<html>
  <head>
    <title>Parabug Estimate Solution Tool</title>
    <meta name="viewport" content="initial-scale=1.0" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <script
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAjdaVy7TYsjGHRblTHwP1_FMurWKyD1Lk&callback=initMap&libraries=drawing,places"
      defer
    ></script>
    <link rel="stylesheet" type="text/css" href="stylesheets/style.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
    <link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
    <script src="//code.jquery.com/jquery-3.3.1.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.js"></script>
    <script src="/js/jsts.1.6.1.js"></script>
    <script src="/js/togeojson.js"></script>
    <!-- <script src="/js/classes.js"></script> -->
  </head>

  <body>
    <div class="map-container">
      <div id="map"></div>
      <input id="pac-input" class="controls" type="text" placeholder="Search..."/>
      <div class="row" id="advanced-options"> 
        <div class="col col-auto" id="advanced-options-button-tab">
          <div id="advanced-options-button">
            <i class="fa fa-cog" aria-hidden="true"></i>
          </div>
        </div>
        <div class="col" id="advanced-options-controls">
          <h4>Draw Settings</h4>
          <hr>
          <h6>Application Area</h6>
          <div>Color: <input type="color" id="app-area-color" value="#FFFF00"></div>
          <div>Opacity: <input type="range" min="1" max="100" value="60" id="app-area-opacity"><span id="app-area-opacity-display">60%</span></div>
          <hr>
          <h6>Hazard Area</h6>
          <div>Color: <input type="color" id="hazard-area-color" value="#FF0000"></div>
          <div>Opacity: <input type="range" min="1" max="100" value="70" id="hazard-area-opacity"><span id="hazard-area-opacity-display">70%</span></div>
          <hr>
          <h6>Variable Rate Area</h6>
          <div>Color: <input type="color" id="vr-area-color" value="#CCCCCC"></div>
          <div>Opacity: <input type="range" min="1" max="100" value="60" id="vr-area-opacity"><span id="vr-area-opacity-display">60%</span></div>
          <hr>
          <!-- <h4>Overlay Settings</h4>
          <hr>
          <div>Color: <input type="color" id="overlay-color" value="#00FF00"></div>
          <div>Opacity: <input type="range" min="1" max="100" value="50" id="overlay-opacity"><span id="overlay-opacity-display">50%</span></div> -->
          <br>
          <div class="row justify-content-center">
            <div class="col col-auto"><input type="button" value="Reset" onclick="resetDisplaySettings()"></div>
            <div class="col col-auto"><input type="button" value="Apply" onclick="applyDisplaySettings()"></div>
          </div>
        </div>
      </div>
    </div>
    <form id="additional-info" method="POST">
      <div id="stat-display">
  
        <!--Bug Name-->
        <div class="stat-item">
          <label class="stat-text" for="bug-name" title="Bug Indicator">Bug:</label>
          <div class="stat-input">
            <input type="text" name="bug-name" id="bug-name" />
          </div>
        </div>
  
        <!--Bugs Per Acre-->
        <div class="stat-item">
          <label class="stat-text" for="num-bugs-per-acre" title="Bugs per acre in the application area">Bugs / Acre:</label>
          <div class="stat-input">
            <input type="number" name="bugs-per-acre" id="num-bugs-per-acre" min="1" value="10000" required/>
          </div>
        </div>
  
        <!--Variable Rate-->
        <div class="stat-item">
          <label class="stat-text" for="variable-rate" title="Bugs per acre in variable rate areas">Variable Rate:</label>
          <div class="stat-input">
            <input type="number" name="variable-rate" id="variable-rate" value="20000" min="0"/>
          </div>
        </div>
  
        <br>
        <div id="add-bug-display">
  
          <!--Bug Name 2-->
          <div class="stat-item">
            <label class="stat-text" for="bug-name2" title="Bug Indicator"> Bug 2:</label>
            <div class="stat-input">
              <input type="text" name="bug-name2" id="bug-name2" />
            </div>
          </div>
  
          <!--Bugs Per Acre 2-->
          <div class="stat-item">
            <label class="stat-text" for="num-bugs-per-acre2" title="Bugs per acre in the application area"> Bugs / Acre 2:</label>
            <div class="stat-input">
              <input type="number" name="bugs-per-acre2" id="num-bugs-per-acre2" min="1" value="10000" required/>
            </div>
          </div>
  
          <!--Variable Rate 2-->
          <div class="stat-item">
            <label class="stat-text" for="variable-rate2" title="Bugs per acre in variable rate areas"> Variable Rate 2:</label>
            <div class="stat-input">
              <input type="number" name="variable-rate2" id="variable-rate2" value="20000" min="0"/>
            </div>
          </div>
        </div>
  
        <br>
  
        <!--Estimated Number of Acres-->
        <div class="stat-item">
          <label class="stat-text" for="num-acres"
            title="Estimated number acres = application area - sum(hazard areas). If incorrect fill in corrected acreage value">
            Acres:
          </label>
          <div class="stat-input">
            <input type="number" name="num-acres" id="num-acres" class="read-only" value="0" readonly/>
          </div>
        </div>
  
        <!--Estimated Total Bugs-->
        <div class="stat-item">
          <label class="stat-text" for="num-bugs" title="Estimated total number of bugs">Total Bugs:</label>
          <div class="stat-input">
            <input type="number" name="num-bugs" id="num-bugs" class="read-only" value="0" readonly/>
          </div>
        </div>
  
        <!-- Add Bug -->
        <div class="stat-item">
          <label class="stat-text" for="add-bug-toggle" title="Toggle between 1 and 2 bugs for application">Add Bug:</label>
          <div class="stat-input-checkbox">
            <input type="checkbox" name="add-bug-toggle" id="add-bug-toggle" value="add-bug"/>
          </div>
        </div>
      </div>
  
      <div id="mobile-div">
        <div id="mobile-mode-div">
          <label for="mobile-mode">Crosshair</label>
          <input type="checkbox" value="mobile" id="mobile-mode" name="mobile-mode"/>
        </div>
        <div id="mobile-options-div">
          <input type="button" value="Mark / Select" onClick="makeMarker()" />
          <input type="button" value="Finish" onClick="finishShape()" />
        </div>
      </div>
  
      <div id="user-info-display">
        <img id="logo-img" src="/img/logo-sml.jpg" />
        <br />
  
        <div class="align-input">
          <fieldset class="form-fieldset" id="user-info-fields">
            <legend>User Information</legend>
  
            <!--Contact Name-->
            <div class="form-element">
              <div class="form-text">
                Contact Name<span class="required">*</span>
              </div>
              <div class="form-input">
                <input type="text" name="contact_name" id="contact-name" required/>
              </div>
            </div>
  
            <!--Contact Phone-->
            <div class="form-element">
              <div class="form-text">
                Contact Phone<span class="required">*</span>
              </div>
              <div class="form-input">
                <input type="text" name="contact_phone" id="contact-phone" required/>
              </div>
            </div>
  
            <!--Contact Email-->
            <div class="form-element">
              <div class="form-text">
                Contact Email<span class="required">*</span>
              </div>
              <div class="form-input">
                <input type="text" name="contact_email" id="contact-email" required/>
              </div>
            </div>
  
            <!--Billing Address-->
            <div class="form-element">
              <div class="form-text">
                Billing Address<span class="required">*</span>
              </div>
              <div class="form-input">
                <input type="text" name="billing_address" id="billing-address" required />
              </div>
            </div>
          </fieldset>
  
          <fieldset class="form-fieldset" id="application-area-fields">
            <legend>Application Area</legend>
  
            <!--Crop-->
            <div class="form-element">
              <label class="form-text">
                <span class="click-tip" onclick="showTip('crop')">Crop</span>
                <span class="required">*</span>
              </label>
              <div class="form-input">
                <input type="text" name="crop" id="crop" required/>
              </div>
            </div>
  
            <!--Row Spacing-->
            <div class="form-element">
              <label class="form-text">
                <span class="click-tip" onclick="showTip('row-spacing')">Spacing (ft)</span>
                <span class="required">*</span>
              </label>
              <div class="form-input">
                <input type="number" step="0.01" name="row_spacing" id="row-spacing" required/>
              </div>
            </div>
  
            <!-- Ranch Name -->
            <div class="form-element">
              <label class="form-text" for="ranch-name">Ranch Name</label>
              <div class="form-input">
                <input type="text" name="ranch-name" id="ranch-name"/>
              </div>
            </div>
  
            <!-- Corrected Acreage -->
            <div class="form-element">
              <label class="form-text">
                <span class="click-tip" onclick="showTip('corrected-acreage')"> Corrected Acreage </span>
              </label>
              <div class="form-input">
                <input type="number" step="0.01" name="corrected-acreage" id="corrected-acreage"/>
              </div>
            </div>
          </fieldset>
  
          <fieldset class="form-fieldset" id="user-preference-fields">
            <legend>Preferences</legend>
  
            <!-- Desired Application Date -->
            <div class="form-element">
              <label class="form-text">
                <span class="click-tip" onclick="showTip('application-date')"> Application Date </span>
              </label>
              <div class="form-input">
                <input type="date" name="application-date" id="application-date"/>
              </div>
            </div>
  
            <!-- Operator Preference -->
            <div class="form-element">
              <label class="form-text">
                <span class="click-tip" onclick="showTip('operator')"> Operator </span>
              </label>
              <div class="form-input">
                <input type="text" name="operator" id="operator"/>
              </div>
            </div>
  
            <!-- Notes -->
            <div class="form-element">
              <label class="form-text">
                <span class="click-tip" onclick="showTip('notes')">Notes</span>
              </label>
              <div class="form-input">
                <textarea name="notes" id="notes" rows="3"></textarea>
              </div>
            </div>
          </fieldset>
  
          <!-- Help -->
          <div style="padding-left: 10px;">
            <div style="cursor:help">Required<span class="required">*</span></div>
            <span class="click-tip"> Click elements for more information </span>
            <br />
          </div>
        </div>
  
        <div class="form-element" id="submitRequest">
          <div class="form-input">
            <input style="font-size: 16px;" type="submit" value="Submit Request"/>
          </div>
        </div>
      </div>
    </form>
  
    <!-- The Modal -->
    <div id="tip-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <span class="modal-close" id="modal-close">&times;</span>
          <div id="modal-header"></div>
        </div>
        <div class="modal-body">
          <div id="modal-body"></div>
          <br />
        </div>
      </div>
    </div>
    <script>
      /*
        CLASSES (SAFARI REFERENCE ERROR TEMP FIX)
      */
      class Hazard {
    constructor(map, poly) {
        // map is a google maps map object
        this.map = map;
        // initialize the path on the map
        this.poly = poly;
    }

    del() {
        this.poly.setMap(null);
        this.poly = null;
        this.map = null;
    }

    getCentroid() {
        var gF = new jsts.geom.GeometryFactory();
        var jstsPoly = AppArea.createJstsPolygon(gF, this.getPoly());
        var c = jsts.algorithm.Centroid.getCentroid(jstsPoly);
        return { lat: c.x, lng: c.y };
    }

    getPoly() {
        return this.poly;
    }
}

      class VariableRateArea {
          constructor(map, poly) {
              // map is a google maps map object
              this.map = map;
              // initialize the path on the map
              this.poly = poly;
          }

          del() {
              this.poly.setMap(null);
              this.poly = null;
              this.map = null;
          }

          getCentroid() {
              var gF = new jsts.geom.GeometryFactory();
              var jstsPoly = AppArea.createJstsPolygon(gF, this.getPoly());
              var c = jsts.algorithm.Centroid.getCentroid(jstsPoly);
              return { lat: c.x, lng: c.y };
          }

          getPoly() {
              return this.poly;
          }
      }

      class AppArea {
          static buffer = .0000005;
          static fill = "#FFFF00";
          static opacity = 0.6;
          static hazardFill = "#FF0000";
          static hazardOpacity = 0.7;
          static vrFill = "#CCCCCC";
          static vrOpacity = 0.6;

          constructor(map, path, hazards = [], vRAs = []) {
              // map is a google maps map object
              this.map = map;
              // hazards contains an array of inner polygons
              this.hazards = hazards;
              // variable rate areas contain an array of inner polygons
              this.variableRateAreas = vRAs;
              // initialize the path on the map
              this.init(path);

              this.subPolyId = 0;
          }

          init(path) {
              this.poly = new google.maps.Polygon({
                  paths: path,
                  strokeColor: '#000000',
                  strokeOpacity: 1,
                  strokeWeight: 1,
                  fillColor: AppArea.fill,
                  fillOpacity: AppArea.opacity,
                  zIndex: 0,
              });
              this.poly.setMap(this.map);
          }

          addHazard(path, holes = []) {
              var allPaths = holes;
              allPaths.unshift(path);

              var identifier = {
                  "type": "hazard",
                  "id": this.subPolyId
              };
              this.subPolyId += 1;

              var poly = this.createHazardPoly(allPaths, identifier);
              var hazard = new Hazard(this.map, poly);
              this.hazards.push(hazard);
              return true;
          }

          addVariableRate(path, holes = []) {
              var allPaths = holes;
              allPaths.unshift(path);

              var identifier = {
                  "type": "variable",
                  "id": this.subPolyId
              };
              this.subPolyId += 1;

              var poly = this.createVariableRatePoly(allPaths, identifier);
              var vra = new VariableRateArea(this.map, poly);
              this.variableRateAreas.push(vra);
              return true;
          }

          clearHazards() {
              var i = this.getNumHazard() - 1;
              while (i >= 0) {
                  this.removeHazard(i);
                  i--;
              }
          }

          clearVariableRateAreas() {
              var i = this.getNumVariableRateAreas() - 1;
              while (i >= 0) {
                  this.removeVariableRateArea(i);
                  i--;
              }
          }

          createHazardPoly(paths, id) {
              var poly = new google.maps.Polygon({
                  paths: paths,
                  strokeColor: '#000000',
                  strokeOpacity: 0.8,
                  strokeWeight: 1,
                  fillColor: AppArea.hazardFill,
                  fillOpacity: AppArea.hazardOpacity,
                  zIndex: 1,
                  identifier: id
              });
              poly.setMap(this.map);
              google.maps.event.addListener(poly, "click", function (event) {
                  // console.log(this.identifier); 
                  promptAndDelete(this.identifier);
              });
              return poly;
          }

          createVariableRatePoly(paths, id) {
              var poly = new google.maps.Polygon({
                  paths: paths,
                  strokeColor: '#000000',
                  strokeOpacity: 1,
                  strokeWeight: 1,
                  fillColor: AppArea.vrFill,
                  fillOpacity: AppArea.vrOpacity,
                  zIndex: 2,
                  identifier: id
              });
              poly.setMap(this.map);
              google.maps.event.addListener(poly, "click", function (event) {
                  // console.log(this.identifier);
                  promptAndDelete(this.identifier);
              });
              return poly;
          }

          del() {
              this.clearHazards();
              this.clearVariableRateAreas();
              if (this.poly != null) { this.poly.setMap(null); }
              this.poly = null;
              this.map = null;
          }

          deleteNonPolys() {
              if (AppArea.numUniqueCoordinates(this.getPoly()) < 3) {
                  console.log("Application area is not a polygon");
                  this.del();
                  return false;
              }

              // Check to see if any hazard has less than 3 unique coordinates, if so then delete
              for (var i = this.getNumHazard() - 1; i >= 0; i--) {
                  if (AppArea.numUniqueCoordinates(this.getHazard(i).getPoly()) < 3) {
                      this.removeHazard(i);
                  }
              }

              // Check to see if any variable rate area has less than 3 unique coordinates, if so then delete
              for (i = this.getNumVariableRateAreas() - 1; i >= 0; i--) {
                  if (AppArea.numUniqueCoordinates(this.getVariableRateArea(i).getPoly()) < 3) {
                      this.removeVariableRateArea(i);
                  }
              }
              return true;
          }

          deleteSelfIntersections() {
              var gF = new jsts.geom.GeometryFactory();

              // Check to see if application area has self intersections, if so then delete
              var jstsPoly = AppArea.createJstsPolygon(gF, this.getPoly());
              if (!jstsPoly.isSimple()) {
                  console.log("Application area is not simple, it may have self intersections");
                  this.del();
                  return false;
              }

              // Check to see if any hazard has self intersections, if so then delete
              // Traverse backwards to avoid shifting issue
              for (var i = this.getNumHazard() - 1; i >= 0; i--) {
                  jstsPoly = AppArea.createJstsPolygon(gF, this.getHazard(i).getPoly());
                  if (!jstsPoly.isSimple()) { this.removeHazard(i); }
              }

              // Check to see if any variable rate area has self intersections, if so then delete
              // Traverse backwards to avoid shifting issue
              for (i = this.getNumVariableRateAreas() - 1; i >= 0; i--) {
                  jstsPoly = AppArea.createJstsPolygon(gF, this.getVariableRateArea(i).getPoly());
                  if (!jstsPoly.isSimple()) { this.removeVariableRateArea(i); }
              }
              return true;
          }

          /*
              Returns the total square acreage of the application area
          */
          getArea() {
              var sqAcres = AppArea.googlePathToAcreage(this.getPoly().getPath());
              if (sqAcres < 0.00001) { return 0; }
              return sqAcres;
          }

          /*
              Returns the sum of square acreage of the hazard areas
          */
          getHazardArea() {
              var tempArea = 0;
              for (var i = 0; i < this.getNumHazard(); i++) {
                  tempArea += AppArea.googlePathToAcreage(this.getHazard(i).getPoly().getPath());
              }
              return tempArea;
          }

          /*
              Returns the sum of square acreage of the variable rate areas
          */
          getVRAArea() {
              var tempArea = 0;
              for (var i = 0; i < this.getNumVariableRateAreas(); i++) {
                  tempArea += AppArea.googlePathToAcreage(this.getVariableRateArea(i).getPoly().getPath());
              }
              return tempArea;
          }

          /*
              Returns the total square acreage of the application area
              Minus the hazard area 
              (Validation should happen first, overlaps are not addressed)
          */
          getAdjustedArea() {
              var sqAcres = AppArea.googlePathToAcreage(this.getPoly().getPath());
              sqAcres -= this.getHazardArea();
              if (sqAcres < 0.00001) { return 0; }
              return sqAcres;
          }

          getCentroid() {
              if (this.getPoly() == null) { return null; }
              var gF = new jsts.geom.GeometryFactory();
              var jstsPoly = AppArea.createJstsPolygon(gF, this.getPoly());
              var c = jsts.algorithm.Centroid.getCentroid(jstsPoly);
              return { lat: c.x, lng: c.y };

          }

          getIndexOfIdentifier(id, type = null) {
              var both = false;
              if (type == null) {
                  both = true;
              }
              if ((type == "hazard") || both) {
                  for (var i = 0; i < this.getNumHazard(); i++) {
                      if (this.getHazard(i).getPoly().identifier.id == id) {
                          return i;
                      }
                  }
              }
              if ((type == "variable") || both) {
                  for (i = 0; i < this.getNumVariableRateAreas(); i++) {
                      if (this.getVariableRateArea(i).getPoly().identifier.id == id) {
                          return i;
                      }
                  }
              }
              return -1;
          }

          getHazard(index) {
              if (index < this.hazards.length) {
                  return this.hazards[index];
              }
              return null;
          }

          getVariableRateArea(index) {
              if (index < this.variableRateAreas.length) {
                  return this.variableRateAreas[index];
              }
              return null;
          }

          getMap() {
              return this.map;
          }

          getNumHazard() {
              return this.hazards.length;
          }

          getNumVariableRateAreas() {
              return this.variableRateAreas.length;
          }

          getPoly() {
              return this.poly;
          }

          getTotalBugs(standard, variableRate) {
              if (this.getPoly() == null) { return 0; }
              var appArea = this.getAdjustedArea(); // get app area in acres
              var vrArea = this.getVRAArea();
              appArea -= vrArea;
              return ((appArea * standard) + (vrArea * variableRate));
          }

          jstsCoordsToShellHoles(coords) {
              let shell = [];
              let holes = [];
              let shellComplete = false;

              for (let i = 0; i < coords.length; i++) {
                  if (!shellComplete) {
                      shell.push(coords[i]);
                      if ((i != 0) && (coords[0].equals(coords[i]))) {
                          shellComplete = true;
                      }
                  } else {
                      holes.push(coords[i]);
                  }
              }
              return { shell, holes };
          }

          removeHazard(index) {
              if (index < this.hazards.length) {
                  this.hazards[index].del();
                  this.hazards[index] = null;
                  this.hazards.splice(index, 1);
                  return true;
              }
              return false;
          }

          removeVariableRateArea(index) {
              if (index < this.variableRateAreas.length) {
                  this.variableRateAreas[index].del();
                  this.variableRateAreas[index] = null;
                  this.variableRateAreas.splice(index, 1);
                  return true;
              }
              return false;
          }

          resetGlobals() {
              if (this.marker != null) {
                  this.marker.setMap(null);
                  this.marker = null;
              }
              if (this.infoWindow != null) {
                  this.infoWindow.setMap(null);
                  this.infoWindow = null;
              }
              this.deleteIdentifier = null;
          }

          setVariableRateArea(index, path, holes = []) {
              if (index < this.variableRateAreas.length) {
                  this.variableRateAreas[index].del();
                  this.variableRateAreas[index] = null;
                  var allPaths = holes;
                  allPaths.unshift(path);

                  var identifier = {
                      "type": "variable",
                      "id": this.subPolyId
                  };
                  this.subPolyId += 1;

                  var poly = this.createVariableRatePoly(allPaths, identifier);
                  var vra = new VariableRateArea(this.map, poly);
                  this.variableRateAreas[index] = vra;
                  return true;
              }
              return false;
          }

          /*
              Converts each polygon (Hazard Area, Variable Rate Area) contained within this object to its simplest form.
              A polygon can be simplified if:
                  - Its inner and outer boundaries remain the same after removing one of its vertices.
                  - The polygon has atleast 4 vertices
              Method:
                  - Get path for polygon with and without a given point
                  - if (pathWithPoint + buffer).covers(pathWithoutPoint) && (pathWithoutPoint + buffer).covers(pathWithPoint)
                      - There are boundaries are the same, continue with the pathWithoutPoint
          */
          simplify() {
              let gF = new jsts.geom.GeometryFactory();
              // Simplify Hazard Areas
              let newHazards = [];
              for (let i = 0; i < this.getNumHazard(); i++) {
                  let hazard = AppArea.createJstsPolygon(gF, this.getHazard(i).getPoly());
                  if (hazard) {
                      let hazardCoords = this.jstsCoordsToShellHoles(hazard.getCoordinates());
                      for (let j = 1; j < hazardCoords.shell.length - 1; j++) {
                          let shellWithPoint = hazardCoords.shell.slice();
                          let shellWithoutPoint = shellWithPoint.slice();
                          shellWithoutPoint.splice(j, 1);
                          if (shellWithPoint.length > 3 && shellWithoutPoint.length > 3) {
                              let polygonWithPoint = gF.createPolygon(gF.createLinearRing(shellWithPoint), gF.createLinearRing(hazardCoords.holes));
                              let polygonWithoutPoint = gF.createPolygon(gF.createLinearRing(shellWithoutPoint), gF.createLinearRing(hazardCoords.holes));
                              let polygonWithPointBuffered = polygonWithPoint.buffer(AppArea.buffer, 1, jsts.operation.buffer.BufferParameters.CAP_SQUARE);
                              let polygonWithoutPointBuffered = polygonWithoutPoint.buffer(AppArea.buffer, 1, jsts.operation.buffer.BufferParameters.CAP_SQUARE);
                              if (polygonWithPointBuffered.covers(polygonWithoutPoint) && polygonWithoutPointBuffered.covers(polygonWithPoint)) {
                                  hazardCoords.shell = shellWithoutPoint.slice();
                              }
                          }
                      }
                      hazardCoords.shell = hazardCoords.shell.map((coord) => {
                          return {
                              'lat': coord.x,
                              'lng': coord.y
                          };
                      });
                      hazardCoords.holes = hazardCoords.holes.map((coord) => {
                          return {
                              'lat': coord.x,
                              'lng': coord.y
                          };
                      });
                      newHazards.push(hazardCoords);
                  }
              }
              while (this.getNumHazard() > 0) { this.removeHazard(0); }
              for (let i = 0; i < newHazards.length; i++) {
                  this.addHazard(newHazards[i].shell, newHazards[i].holes);
              }


              // Simplify Variable Rate Areas
              let newVRAs = [];
              for (let i = 0; i < this.getNumVariableRateAreas(); i++) {
                  let vra = AppArea.createJstsPolygon(gF, this.getVariableRateArea(i).getPoly());
                  if (vra) {
                      let vraCoords = this.jstsCoordsToShellHoles(vra.getCoordinates());
                      for (let j = 1; j < vraCoords.shell.length - 1; j++) {
                          let shellWithPoint = vraCoords.shell.slice();
                          let shellWithoutPoint = shellWithPoint.slice();
                          shellWithoutPoint.splice(j, 1);
                          if (shellWithPoint.length > 3 && shellWithoutPoint.length > 3) {
                              let polygonWithPoint = gF.createPolygon(gF.createLinearRing(shellWithPoint), gF.createLinearRing(vraCoords.holes));
                              let polygonWithoutPoint = gF.createPolygon(gF.createLinearRing(shellWithoutPoint), gF.createLinearRing(vraCoords.holes));
                              let polygonWithPointBuffered = polygonWithPoint.buffer(AppArea.buffer, 1, jsts.operation.buffer.BufferParameters.CAP_SQUARE);
                              let polygonWithoutPointBuffered = polygonWithoutPoint.buffer(AppArea.buffer, 1, jsts.operation.buffer.BufferParameters.CAP_SQUARE);
                              if (polygonWithPointBuffered.covers(polygonWithoutPoint) && polygonWithoutPointBuffered.covers(polygonWithPoint)) {
                                  vraCoords.shell = shellWithoutPoint.slice();
                              }
                          }
                      }
                      vraCoords.shell = vraCoords.shell.map((coord) => {
                          return {
                              'lat': coord.x,
                              'lng': coord.y
                          };
                      });
                      vraCoords.holes = vraCoords.holes.map((coord) => {
                          return {
                              'lat': coord.x,
                              'lng': coord.y
                          };
                      });
                      newVRAs.push(vraCoords);
                  }
              }
              while (this.getNumVariableRateAreas() > 0) { this.removeVariableRateArea(0); }
              for (let i = 0; i < newVRAs.length; i++) { this.addVariableRate(newVRAs[i].shell, newVRAs[i].holes); }
          }

          /*
              Converts THIS object into an object which is easily converted to JSON (for sending)
              "ApplicationArea",
                  [{
                      "shell": [{lat,lng}], <- take first shell (should only have 1)
                      "holes": [ [{lat,lng}] ]
                  }]
              "Hazards",
                  [
                      [{ "shell", "holes" }]
                  ]
              "VariableRateAreas"
                  [
                      [{ "shell", "holes" }]
                  ]
          */
          toEasyFormat() {
              try {

                  if (this.getPoly() == null) { return null; }
                  var gF = new jsts.geom.GeometryFactory();
                  var temp;

                  temp = AppArea.createJstsPolygon(gF, this.getPoly());
                  temp = AppArea.getGeoShellsHoles(temp);
                  var appArea = AppArea.shellsHolesToCoords(temp);

                  var hazards = [];
                  for (var i = 0; i < this.getNumHazard(); i++) {
                      temp = AppArea.createJstsPolygon(gF, this.getHazard(i).getPoly());
                      temp = AppArea.getGeoShellsHoles(temp);
                      temp = AppArea.shellsHolesToCoords(temp);
                      hazards.push(temp);
                  }

                  var vras = [];
                  for (i = 0; i < this.getNumVariableRateAreas(); i++) {
                      temp = AppArea.createJstsPolygon(gF, this.getVariableRateArea(i).getPoly());
                      temp = AppArea.getGeoShellsHoles(temp);
                      temp = AppArea.shellsHolesToCoords(temp);
                      vras.push(temp);
                  }

                  var json = {
                      "ApplicationArea": appArea,
                      "Hazards": hazards,
                      "VariableRateAreas": vras
                  };

                  return json;
              } catch (e) {
                  console.log(e);
              }
          }

          trimHazards() {
              var trimmed = [];
              var outer = this.getPoly();
              var inner, result;
              for (var i = 0; i < this.getNumHazard(); i++) {
                  inner = this.getHazard(i).getPoly();
                  result = AppArea.trimPolygon(inner, outer);
                  if (result != null) {
                      for (var j = 0; j < result.length; j++) {
                          trimmed.push(result[j]);
                      }
                  }
              }

              // clear hazards
              for (let i = this.getNumHazard() - 1; i >= 0; i--) {
                  this.removeHazard(i);
              }
              // Add trimmed hazards
              for (let i = 0; i < trimmed.length; i++) {
                  this.addHazard(trimmed[i].shell, trimmed[i].holes);
              }

          }

          trimVariableRateAreas() {
              var outer = this.getPoly();
              var inner, result;
              var trimmed = [];

              // Trim variable rate ares to be within application area
              for (var i = 0; i < this.getNumVariableRateAreas(); i++) {
                  inner = this.getVariableRateArea(i).getPoly();
                  result = AppArea.trimPolygon(inner, outer);
                  if (result != null) {
                      for (var j = 0; j < result.length; j++) { trimmed.push(result[j]); }
                  }
              }

              // clear vras
              while (this.getNumVariableRateAreas() > 0) {
                  this.removeVariableRateArea(0);
              }

              // Add trimmed vras
              for (let i = 0; i < trimmed.length; i++) {
                  this.addVariableRate(trimmed[i].shell, trimmed[i].holes);
              }


              // Trim variable rate ares to not overlap with any hazards
              var vra, haz;
              for (let i = 0; i < this.getNumHazard(); i++) {
                  // Reset trimmed
                  trimmed = [];
                  haz = this.getHazard(i).getPoly();
                  for (let j = 0; j < this.getNumVariableRateAreas(); j++) {
                      vra = this.getVariableRateArea(j).getPoly();
                      result = AppArea.getDifference(vra, haz);
                      if (result != null) {
                          for (let k = 0; k < result.length; k++) { trimmed.push(result[k]); }
                      }
                  }
                  // clear hazards
                  while (this.getNumVariableRateAreas() > 0) { this.removeVariableRateArea(0); }
                  // Add trimmed hazards
                  for (let i = 0; i < trimmed.length; i++) { this.addVariableRate(trimmed[i].shell, trimmed[i].holes); }
              }
          }

          unionHazards() {
              // Return now if only 1 hazard is left, not necessary but decreases time by one loop
              if (this.getNumHazard() <= 1) { return true; }

              // Setup variables
              var i = 0;
              var numHazards = this.getNumHazard();
              var temp1, temp2, result;
              var unionOccured = false;

              while (i < numHazards) {
                  // Reset bool which indicates if a union was found
                  unionOccured = false;

                  // Get first hazard to compare with rest for union
                  temp1 = this.getHazard(i);

                  // Loop through hazards and compare
                  for (var j = 0; j < numHazards; j++) {

                      // If not the same hazard
                      if (j != i) {

                          // Get the other hazard and find the union of the two
                          temp2 = this.getHazard(j);
                          result = AppArea.unionPolygons(temp1.getPoly(), temp2.getPoly());

                          // Check if the two hazards were actually unioned (they interesected and a new path was made)
                          if (result.unioned == 1) {

                              // Remove the original hazard at index i
                              this.removeHazard(i);

                              // Remove the original hazard at index j
                              // But adjust for shift from deletion of i
                              if (i < j) { this.removeHazard(j - 1); }
                              else { this.removeHazard(j); }

                              // Add new unioned hazard
                              this.addHazard(result.shell, result.holes);

                              // Set bool to true to indicate a union has occured 
                              unionOccured = true;

                              // Adjust numhazards to reflect new additions and deletions
                              numHazards = this.getNumHazard();
                              break;
                          }
                      }
                  }

                  // Increment hazard index to check
                  i++;

                  // Indexes have shifted and new paths were added, restart loop
                  if (unionOccured) { i = 0; }

                  // Return now if only 1 hazard is left, not necessary but decreases time by one loop
                  if (numHazards <= 1) { return; }
              }
          }

          unionVariableRateAreas() {
              if (this.getNumVariableRateAreas() <= 1) { return; }
              let unionOccured = false;
              do {
                  unionOccured = false;
                  for (let i = 0; ((i < this.getNumVariableRateAreas()) && !unionOccured); i++) {
                      let temp1 = this.getVariableRateArea(i);
                      for (let j = 0; ((j < this.getNumVariableRateAreas()) && !unionOccured); j++) {
                          if (j != i) {
                              let temp2 = this.getVariableRateArea(j);
                              let result = AppArea.unionPolygons(temp1.getPoly(), temp2.getPoly());
                              if (result.unioned == 1) {
                                  unionOccured = true;
                                  if (i > j) {
                                      this.removeVariableRateArea(i);
                                      this.removeVariableRateArea(j);
                                  } else {
                                      this.removeVariableRateArea(j);
                                      this.removeVariableRateArea(i);
                                  }
                                  this.addVariableRate(result.shell, result.holes);
                              }
                          }
                      }
                  }
              } while (unionOccured);
          }

          validateAndFix() {
              try {
                  if (this.getPoly() == null) { return false; }
                  if (!this.deleteNonPolys()) { return false; }
                  if (!this.deleteSelfIntersections()) { return false; }
                  this.unionHazards();
                  this.trimHazards();
                  this.unionVariableRateAreas();
                  this.trimVariableRateAreas();
                  this.simplify();
                  return true;
              } catch (e) {
                  console.log(e);
              }
              return false;
          }

          static covers(outer, inner) {
              var gF = new jsts.geom.GeometryFactory();

              var jstsInner = AppArea.createJstsPolygon(gF, inner);
              var jstsOuter = AppArea.createJstsPolygon(gF, outer);

              jstsInner.normalize();
              jstsOuter.normalize();

              return jstsOuter.covers(jstsInner);
          }

          /*
              Given a jsts geometry factory and a Google Maps Polygon
              Returns a jsts polygon on mutlipolygon
              Errors on polygon with less than 3 unique points (2d)
          */
          static createJstsPolygon(geometryFactory, polygon) {
              if (!polygon) { return null; }
              var path = polygon.getPaths();

              // Get path of outer shell
              var coordinates = path.getAt(0).getArray().map(function name(coord) {
                  return new jsts.geom.Coordinate(coord.lat(), coord.lng());
              });
              if (coordinates.length < 3) { return null; }
              if (coordinates[0].compareTo(coordinates[coordinates.length - 1]) != 0) {
                  coordinates.push(coordinates[0]);
              }
              var shell = geometryFactory.createLinearRing(coordinates);

              // Get paths of holes
              var holes = [];
              for (var i = 1; i < path.getLength(); i++) {
                  coordinates = path.getAt(i).getArray().map(function name(coord) {
                      return new jsts.geom.Coordinate(coord.lat(), coord.lng());
                  });
                  if (coordinates[0].compareTo(coordinates[coordinates.length - 1]) != 0) {
                      coordinates.push(coordinates[0]);
                  }
                  holes.push(geometryFactory.createLinearRing(coordinates));
              }

              return geometryFactory.createPolygon(shell, holes);
          }

          /*
              Takes in a jsts geometry/linear ring and returns an array of objects:
              {
                  lat - latitude coordinate of point
                  lng - longitude coordinate of point
              }
          */
          static getCoords(poly) {
              var coords = poly.getCoordinates().map(function (coord) {
                  return { lat: coord.x, lng: coord.y };
              });
              return coords;
          }

          /*
              Removes area the area of a polygon that overlaps with another
              Takes two google polygons and returns array of objects:
              {
                  shell   - (coordinates) the outer path of the difference,
                  [holes]   - (coordinates) the inner paths of the difference, representing holes (if any)
              }
          */
          static getDifference(poly, polyRemove) {
              try {
                  var gF = new jsts.geom.GeometryFactory();

                  var jstsPoly = AppArea.createJstsPolygon(gF, poly);
                  var jstsPolyRemove = AppArea.createJstsPolygon(gF, polyRemove)

                  if (!jstsPoly) { return null; }
                  if (!jstsPolyRemove) { return poly; }

                  // jstsPoly.normalize();
                  // jstsPolyRemove.normalize();

                  let difference = jstsPoly.difference(jstsPolyRemove.buffer(AppArea.buffer, 1, jsts.operation.buffer.BufferParameters.CAP_SQUARE));

                  var shellsHoles = AppArea.getGeoShellsHoles(difference);

                  var result = AppArea.shellsHolesToCoords(shellsHoles);

                  return result;
              } catch (e) {
                  console.log(e);
                  return null;
              }
          }

          /*
              Takes in a geometry and returns an array of
              {
                  shell   - (Google Linear Ring) the outer path
                  [holes]   - (Google Linear Ring) the inner paths, representing holes (if any)
              }
          */
          static getGeoShellsHoles(jstsGeom) {
              if (!jstsGeom) { return []; }
              var result = [];
              var tempHoles;
              var tempGeo;
              var numGeometries = jstsGeom.getNumGeometries();

              if (numGeometries < 1) { return []; }

              if (numGeometries == 1) {
                  tempHoles = [];
                  for (var j = 0; j < jstsGeom.getNumInteriorRing(); j++) {
                      tempHoles.push(jstsGeom.getInteriorRingN(j));
                  }
                  result.push({
                      "shell": jstsGeom.getExteriorRing(),
                      "holes": tempHoles
                  });
                  return result;
              }

              for (var i = 0; i < numGeometries; i++) {
                  tempHoles = [];
                  tempGeo = jstsGeom.getGeometryN(i);
                  for (j = 0; j < tempGeo.getNumInteriorRing(); j++) {
                      tempHoles.push(tempGeo.getInteriorRingN(j));
                  }
                  result.push({
                      "shell": tempGeo.getExteriorRing(),
                      "holes": tempHoles
                  });
              }
              return result;
          }

          static googlePathToAcreage(path) {
              var area = google.maps.geometry.spherical.computeArea(path); // square meters
              var sqAcres = area / 4046.8564224; // to square acres 
              if (sqAcres < 0.00001) { return 0; }
              return sqAcres;
          }

          /*
              Given a Google Maps Polygon
              Returns the number of unique coordinates found
              1  -  Indicates a single point
              2  -  A line (2d)
              3+ -  A polygon
          */
          static numUniqueCoordinates(polygon) {
              var path = polygon.getPaths();

              // Get path of outer shell
              var coordinates = path.getAt(0);
              var unique = [];
              var coordTemp, newCoord;
              for (var i = 0; i < coordinates.length; i++) {
                  coordTemp = coordinates.getAt(i);
                  newCoord = {
                      'lat': coordTemp.lat(),
                      'lng': coordTemp.lng()
                  };
                  if (unique.indexOf(newCoord) == -1) {
                      unique.push(newCoord);
                  }
              }
              return unique.length;
          }

          /*
              Converts an array of 
              {
                  shell   - (Google Linear Ring) the outer path
                  [holes]   - (Google Linear Ring) the inner paths, representing holes (if any)
              }
              Into an array of
              {
                  shell   - (coordinates) the outer path
                  [holes]   - (coordinates) the inner paths, representing holes (if any)
              }
          */
          static shellsHolesToCoords(shellsHoles) {
              var result = [];
              var tempShell;
              var tempHoles;
              for (var i = 0; i < shellsHoles.length; i++) {
                  tempShell = AppArea.getCoords(shellsHoles[i].shell);
                  tempHoles = [];
                  for (var j = 0; j < shellsHoles[i].holes.length; j++) {
                      tempHoles.push(AppArea.getCoords(shellsHoles[i].holes[j]));
                  }
                  result.push({
                      "shell": tempShell,
                      "holes": tempHoles
                  });
              }
              return result;
          }

          /*
              Trims the inner polygon to be contained within the outer polygon
              Takes two google polygons and returns array of objects:
              {
                  shell   - (coordinates) the outer path of the trim (at most, boundaries of outer polygon),
                  [holes]   - (coordinates) the inner paths of the trim, representing holes (if any)
              }
          */
          static trimPolygon(inner, outer) {
              var gF = new jsts.geom.GeometryFactory();

              var jstsInner = AppArea.createJstsPolygon(gF, inner);
              var jstsOuter = AppArea.createJstsPolygon(gF, outer);


              jstsInner.normalize();
              jstsOuter.normalize();

              if (!jstsInner.intersects(jstsOuter)) { return null; }
              var intersection;
              if (jstsOuter.buffer(AppArea.buffer, 1, jsts.operation.buffer.BufferParameters.CAP_BUTT).covers(jstsInner)) {
                  intersection = jstsInner;
              } else {
                  intersection = jstsInner.intersection(jstsOuter);
              }

              var shellsHoles = AppArea.getGeoShellsHoles(intersection);
              var result = AppArea.shellsHolesToCoords(shellsHoles);
              return result;
          }

          /*
              Create a unioned polygon between two input polygons, if intersection occurs
              Takes two google polygons and returns object:
              {
                  shell   - (coordinates) the outer path of the union
                  [holes]   - (coordinates) the inner paths of the union, representing holes (if any)
                  unioned - Status int 1 (union occured) or 2 (union did not occur)
              }
          */
          static unionPolygons(poly1, poly2) {
              var gF = new jsts.geom.GeometryFactory();

              var jstsPoly1 = AppArea.createJstsPolygon(gF, poly1);
              var jstsPoly2 = AppArea.createJstsPolygon(gF, poly2);

              if (!jstsPoly1 && !jstsPoly2) { return { "unioned": 0 }; }

              let result;
              if (!jstsPoly1) { result = jstsPoly2; }
              else if (!jstsPoly2) { result - jstsPoly1; }
              else {
                  jstsPoly1.normalize();
                  jstsPoly2.normalize();
                  if (!jstsPoly1.intersects(jstsPoly2) || jstsPoly1.touches(jstsPoly2)) { return { "unioned": 0 }; }
                  var unioned = jstsPoly1.union(jstsPoly2);
                  var shellsHoles = AppArea.getGeoShellsHoles(unioned);
                  result = AppArea.shellsHolesToCoords(shellsHoles);
              }

              var shell = result[0].shell;
              var holes = result[0].holes;

              return {
                  "shell": shell,
                  "holes": holes,
                  "unioned": 1
              };
          }
      }

      /*      FUNCTIONS      */

      function promptAndDelete(identifier) {
          // Havent found a good way to add event listeners to children polygons, and delete themselves
          // after clicking, so using a named instance variable for now
          // Named instance variable for AppArea is assumed to be appArea

          // check if drawing mode is set to delete
          if (drawModeControl.getCurrent() != "Delete") { return; } // also instanced variable (drawModeControl)

          if (appArea == null) { return; }
          var index = appArea.getIndexOfIdentifier(identifier.id, identifier.type);
          if (index == -1) { return; }
          var centroid;

          if (identifier.type == "hazard") {
              centroid = appArea.getHazard(index).getCentroid();
          } else if (identifier.type == "variable") {
              centroid = appArea.getVariableRateArea(index).getCentroid();
          } else { return; }

          // function to clear markers and infowindow
          appArea.resetGlobals();

          appArea.deleteIdentifier = identifier;

          var marker = new google.maps.Marker({
              position: centroid,
              map: appArea.getMap()
          });

          var infoWindow = new google.maps.InfoWindow({ content: "" });


          // Couldn't pass values easily in content string, utilizing global variable instead
          infoWindow.setContent('<button type="button" onClick="deleteSubPoly()">Delete</button>');
          google.maps.event.addListener(infoWindow, 'closeclick', function () {
              appArea.resetGlobals();
          });

          infoWindow.open(appArea.getMap(), marker);
          appArea.marker = marker;
          appArea.infoWindow = infoWindow;
      }

      function deleteSubPoly() {
          if ((appArea != null) && (appArea.deleteIdentifier != null)) {
              // console.log(appArea.deleteIdentifier);
              index = appArea.getIndexOfIdentifier(appArea.deleteIdentifier.id, appArea.deleteIdentifier.type);
              if (appArea.deleteIdentifier.type == "hazard") {
                  appArea.removeHazard(index);
              } else if (appArea.deleteIdentifier.type = "variable") {
                  appArea.removeVariableRateArea(index);
              }
              appArea.resetGlobals();
              updateStats();
          }
      }

      // http://www.jacklmoore.com/notes/rounding-in-javascript/
      function round(value, decimals) {
          return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);
      }

      /* GLOBAL VARIABLES */
      let map;
      let drawingManager;
      var appArea;
      let infoWindow;
      let centerMarker;
      let overlayMarkers = [];
      let tempShape;
    
      let fileInput = document.createElement("input");
      fileInput.setAttribute("type", "file");
      fileInput.setAttribute("accept", ".kml");
    
      // Internal object to help manage toggling between our custom drawing modes
      let drawModeControl = {
        modes: [
          "Drag",
          "Application Area",
          "Hazard",
          "Variable Rate Area",
          "Delete"
        ],
        hoverText: [
          "Drag map view",
          "Create an application area. \n- Redrawing will reset map.",
          "Create a hazard area. \n- Application area must exist to create hazard areas.",
          "Create a variable rate area. \n- Application area must exist to create variable rate areas. \n- Variable rate areas do not overlap with hazard areas.",
          "Delete selection tool for deleting application areas, hazard areas, and variable rate areas."
        ],
        current: 0,
        getCurrent: function() {
          return this.modes[this.current];
        }
      };
    
      // HTML Elements
      let modal = document.getElementById("tip-modal");
      let bugsPerAcre = document.getElementById("num-bugs-per-acre");
      let percentMultiplier = document.getElementById("variable-rate");
      let bugsPerAcre2 = document.getElementById("num-bugs-per-acre2");
      let percentMultiplier2 = document.getElementById("variable-rate2");
    
      /* FUNCTIONS */
    
      function applyDisplaySettings() {
        let appAreaColor = document.getElementById('app-area-color').value;
        let appAreaOpacity = document.getElementById('app-area-opacity').value;
        let hazardAreaColor = document.getElementById('hazard-area-color').value;
        let hazardAreaOpacity = document.getElementById('hazard-area-opacity').value;
        let vrAreaColor = document.getElementById('vr-area-color').value;
        let vrAreaOpacity = document.getElementById('vr-area-opacity').value;
    
        try {
          if (appArea) {
            appArea.poly.setOptions({
              fillColor: appAreaColor,
              fillOpacity: (appAreaOpacity/100)
            });
            for(let i = 0; i < appArea.getNumHazard(); i++) {
              appArea.getHazard(i).poly.setOptions({
                fillColor: hazardAreaColor,
                fillOpacity: (hazardAreaOpacity/100)
              });
            }
            for(let i = 0; i < appArea.getNumVariableRateAreas(); i++) {
              appArea.getVariableRateArea(i).poly.setOptions({
                fillColor: vrAreaColor,
                fillOpacity: (vrAreaOpacity/100)
              });
            }
          }
          // Static Values
          AppArea.fill = appAreaColor;
          AppArea.opacity = appAreaOpacity/100;
          AppArea.hazardFill = hazardAreaColor;
          AppArea.hazardOpacity = hazardAreaOpacity/100;
          AppArea.vrFill = vrAreaColor;
          AppArea.vrOpacity = vrAreaOpacity/100;
        } catch (e) {
          console.log(e);
        }   
      }
    
      function centerMap() {
        if (appArea == null) {
          return;
        }
        let center = appArea.getCentroid();
        if (center == null) {
          return;
        }
        map.setCenter(center);
      }
    
      function draw(path) {
        let mode = drawModeControl.getCurrent();
        switch (mode) {
          case "Application Area":
            if (appArea) {
              try {
                appArea.del();
              } catch (e) {
                // Continue
              }
              appArea = new AppArea(map, path);
            } else {
              appArea = new AppArea(map, path);
            }
            break;
          case "Hazard":
            if (appArea == null) {
              console.log("No application area defined for hazard");
              return;
            }
            appArea.addHazard(path);
            break;
          case "Variable Rate Area":
            if (appArea == null) {
              console.log("No application area defined for variate rate area");
              return;
            }
            appArea.addVariableRate(path);
            break;
          default:
            break; // unexpected input
        }
        let success = validate();
        updateStats();
      }
    
      function drawToggle(mode) {
        if (appArea != null) {
          appArea.resetGlobals();
        }
    
        // Value defaults in string, parse the int value
        mode = parseInt(mode, 10);
        switch (mode) {
          case 4:
          case 0:
            drawingManager.setOptions({ drawingMode: null });
            drawModeControl.current = mode;
            break;
          case 1: // Fall through
          case 2: // Fall through
          case 3:
            if (document.getElementById("mobile-mode").checked) {
              drawingManager.setOptions({ drawingMode: null });
            } else {
              drawingManager.setOptions({
                drawingMode: google.maps.drawing.OverlayType.POLYGON
              });
            }
            drawModeControl.current = mode;
            break;
          default:
            break; // unexpected input
        }
      }
    
      function finishShape() {
        if (tempShape != null) {
          draw(tempShape.getPath());
          tempShape.setMap(null);
        }
        overlayMarkers = [];
        tempShape = null;
      }
    
      function handleLocationError(browserHasGeolocation) {
        let message = browserHasGeolocation
          ? "Error: The Geolocation service failed."
          : "Error: Your browser doesn't support geolocation.";
        console.log(message);
      }
    
      function importKML() {
        fileInput.click();
      }
    
      function initMap() {
        map = new google.maps.Map(document.getElementById("map"), {
          center: { lat: 36.677756, lng: -121.729448 }, // default
          zoom: 15,
          mapTypeId: "hybrid",
          streetViewControl: false,
          rotateControl: false,
          mapTypeControlOptions: {
            style: google.maps.MapTypeControlStyle.DROPDOWN_MENU
          }
        });
    
        let image = {
          url: "/img/crosshair.png",
          size: new google.maps.Size(200, 200),
          origin: new google.maps.Point(0, 0),
          anchor: new google.maps.Point(100, 100)
        };
    
        centerMarker = new google.maps.Marker({
          position: map.getCenter(),
          icon: image,
          draggable: true,
          // map: map,
          zIndex: 3
        });
    
        drawingManager = new google.maps.drawing.DrawingManager({
          drawingMode: null,
          drawingControl: false,
          map: map,
          polygonOptions: { editable: true }
        });
    
        google.maps.event.addListener(drawingManager, "polygoncomplete", function(p) {
          draw(p.getPath());
          p.setMap(null);
          path = null;
        });
    
        map.setTilt(0);
    
        //*********************************** User Location ************************************
        // Try HTML5 geolocation.
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            function(position) {
              let pos = {
                lat: position.coords.latitude,
                lng: position.coords.longitude
              };
              map.setCenter(pos);
              map.setZoom(15);
              centerMarker.setPosition(pos);
            },
            function() {
              handleLocationError(true);
            }
          );
        } else {
          // Browser doesn't support Geolocation
          handleLocationError(false);
        }
        //********************************* End User Location **********************************
    
        //************************************* Search Box *************************************
        // Create the search box and link it to the UI element.
        let input = document.getElementById("pac-input");
        let searchBox = new google.maps.places.SearchBox(input);
        map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);
    
        // Bias the SearchBox results towards current map's viewport.
        map.addListener("bounds_changed", function() {
          searchBox.setBounds(map.getBounds());
        });
    
        // Listen for the event fired when the user selects a prediction
        searchBox.addListener("places_changed", function() {
          let places = searchBox.getPlaces();
          if (places.length == 0) {
            return;
          }
    
          // For each place, get the location.
          let bounds = new google.maps.LatLngBounds();
          places.forEach(function(place) {
            if (!place.geometry) {
              console.log("Returned place contains no geometry");
              return;
            }
    
            // Only geocodes have viewport
            if (place.geometry.viewport) {
              bounds.union(place.geometry.viewport);
            } else {
              bounds.extend(place.geometry.location);
            }
          });
          map.fitBounds(bounds);
          map.setTilt(0);
        });
        //*********************************** End search Box ***********************************
    
        //*********************************** Custom Controls***********************************
        function MapModeControl(divHolder) {
          // Set CSS for the control border.
          let controlUI = document.createElement("div");
          controlUI.style.backgroundColor = "#fff";
          controlUI.style.border = "2px solid #fff";
          controlUI.style.borderRadius = "3px";
          controlUI.style.cursor = "pointer";
          controlUI.style.marginTop = "10px";
          controlUI.style.padding = "2px";
          controlUI.title = "Select Control Mode";
          controlUI.id = "mode-control-container";
    
          let modeText = document.createElement("div");
          modeText.innerHTML = "Mode: ";
          modeText.style.color = "rgb(25,25,25)";
          modeText.style.fontFamily = "Roboto,Arial,sans-serif";
          modeText.style.fontSize = "15px";
          modeText.style.lineHeight = "30px";
          modeText.style.marginRight = "10px";
          modeText.style.fontWeight = "600";
    
          // Interior
          let modeSelect = document.createElement("select");
          modeSelect.style.color = "rgb(25,25,25)";
          modeSelect.style.fontFamily = "Roboto,Arial,sans-serif";
          modeSelect.style.fontSize = "15px";
          modeSelect.style.lineHeight = "30px";
    
          let mode;
          for (let i = 0; i < drawModeControl.modes.length; i++) {
            mode = document.createElement("option");
            mode.value = i;
            mode.text = drawModeControl.modes[i];
            mode.title = drawModeControl.hoverText[i];
            modeSelect.appendChild(mode);
          }
          modeSelect.addEventListener("change", function() {
            let index = modeSelect.selectedIndex;
            let value = modeSelect.options[index].value;
            drawToggle(value);
          });
    
          controlUI.appendChild(modeText);
          controlUI.appendChild(modeSelect);
          divHolder.appendChild(controlUI);
        }
    
        /* Advanced Options Button and Tab*/
        let advancedOptions = document.getElementById('advanced-options');
        map.controls[google.maps.ControlPosition.RIGHT_CENTER].push(advancedOptions);
        document.getElementById("advanced-options-button").click();
    
        /* Map Modes Control */
        let modeSelectionDiv = document.createElement("div");
        MapModeControl(modeSelectionDiv);
        modeSelectionDiv.index = 1;
        map.controls[google.maps.ControlPosition.TOP_LEFT].push(modeSelectionDiv);
    
        function customControl(divHolder, text, callback) {
          // Set CSS for the control border.
          let controlUI = document.createElement("div");
          controlUI.style.backgroundColor = "#fff";
          controlUI.style.border = "2px solid #fff";
          controlUI.style.borderRadius = "3px";
          controlUI.style.cursor = "pointer";
          controlUI.style.margin = "10px";
          controlUI.style.padding = "2px";
          controlUI.style.textAlign = "center";
    
          let controlText = document.createElement("div");
          controlText.innerHTML = text;
          controlText.style.color = "rgb(25,25,25)";
          controlText.style.fontFamily = "Roboto,Arial,sans-serif";
          controlText.style.fontSize = "15px";
          controlText.style.lineHeight = "30px";
          controlText.style.fontWeight = "600";
    
          controlUI.appendChild(controlText);
          divHolder.appendChild(controlUI);
          callback(divHolder);
        }
    
        /* Center Button */
        let centerDiv = document.createElement("div");
        centerDiv.id = "center-btn";
        customControl(centerDiv, "Center", function(div) {
          div.addEventListener("click", centerMap);
        });
        centerDiv.index = 1;
        map.controls[google.maps.ControlPosition.BOTTOM_LEFT].push(centerDiv);
    
        /* Reset Button */
        let resetDiv = document.createElement("div");
        customControl(resetDiv, "Reset", function(div) {
          div.addEventListener("click", resetMap);
        });
        resetDiv.index = 1;
        resetDiv.id = "reset-btn";
        map.controls[google.maps.ControlPosition.BOTTOM_LEFT].push(resetDiv);
        
        /* Import KML Button */
        // let importDiv = document.createElement("div");
        // customControl(importDiv, "Import KML", function(div) {
        //   div.addEventListener("click", importKML);
        // });
        // importDiv.index = 1;
        // importDiv.id = "import-btn";
        // map.controls[google.maps.ControlPosition.BOTTOM_LEFT].push(importDiv);
    
        /* Mobile Controls (Crosshair) */
        let mobileControl = document.getElementById("mobile-div");
        mobileControl.index = 1;
        map.controls[google.maps.ControlPosition.BOTTOM_CENTER].push(mobileControl);
        //********************************* End Custom Controls*********************************
      }
    
      function makeMarker() {
        if (drawModeControl.current == 4) {
          // Delete Mode
          mobileClickSubPoly(centerMarker.getPosition());
          return;
        }
        if (drawModeControl.current == 0) {
          // Drag Mode
          alert("Select a mode.");
          return;
        }
    
        overlayMarkers.push(centerMarker.getPosition());
        if (tempShape != null) {
          tempShape.setMap(null);
        }
        if (overlayMarkers.length == 1) {
          tempShape = new google.maps.Marker({
            position: centerMarker.getPosition(),
            icon: {
              path: google.maps.SymbolPath.CIRCLE,
              scale: 6,
              fillColor: "white",
              fillOpacity: 1,
              strokeColor: "black",
              strokeWeight: 2
            },
            map: map
          });
          return;
        }
    
        // If more than one marker, generate a polyline
        tempShape = new google.maps.Polyline({
          path: overlayMarkers,
          strokeColor: "#000000",
          strokeOpacity: 1,
          strokeWeight: 3,
          draggable: true,
          geodesic: true
        });
        tempShape.setMap(map);
      }
    
      function mobileClickSubPoly(latLng) {
        if (appArea == null) {
          return;
        }
        // Mobile delete selection fix
        let temp;
        for (let i = 0; i < appArea.getNumHazard(); i++) {
          temp = appArea.getHazard(i).getPoly();
          if (google.maps.geometry.poly.containsLocation(latLng, temp)) {
            let mev = {
              stop: null,
              latLng: latLng
            };
            google.maps.event.trigger(temp, "click", mev);
            return;
          }
        }
        for (i = 0; i < appArea.getNumVariableRateAreas(); i++) {
          temp = appArea.getVariableRateArea(i).getPoly();
          if (google.maps.geometry.poly.containsLocation(latLng, temp)) {
            let mev = {
              stop: null,
              latLng: latLng
            };
            google.maps.event.trigger(temp, "click", mev);
            return;
          }
        }
        console.log("No subpoly contained spot");
      }
    
      function resetDisplaySettings() {
        let appAreaColor = "#FFFF00";
        let appAreaOpacity = 0.6;
        let hazardAreaColor = "#FF0000";
        let hazardAreaOpacity = 0.7;
        let vrAreaColor = "#CCCCCC";
        let vrAreaOpacity = 0.6;
    
        document.getElementById('app-area-color').value = appAreaColor;
        document.getElementById('app-area-opacity').value = appAreaOpacity * 100;
        document.getElementById('hazard-area-color').value = hazardAreaColor;
        document.getElementById('hazard-area-opacity').value = hazardAreaOpacity * 100;
        document.getElementById('vr-area-color').value = vrAreaColor;
        document.getElementById('vr-area-opacity').value = vrAreaOpacity * 100;
    
        try {
          if (appArea) {
            appArea.poly.setOptions({
              fillColor: appAreaColor,
              fillOpacity: appAreaOpacity
            });
            for(let i = 0; i < appArea.getNumHazard(); i++) {
              appArea.getHazard(i).poly.setOptions({
                fillColor: hazardAreaColor,
                fillOpacity: hazardAreaOpacity
              });
            }
            for(let i = 0; i < appArea.getNumVariableRateAreas(); i++) {
              appArea.getVariableRateArea(i).poly.setOptions({
                fillColor: vrAreaColor,
                fillOpacity: vrAreaOpacity
              });
            }
          }
          // Static Values
          AppArea.fill = appAreaColor;
          AppArea.opacity = appAreaOpacity/100;
          AppArea.hazardFill = hazardAreaColor;
          AppArea.hazardOpacity = hazardAreaOpacity/100;
          AppArea.vrFill = vrAreaColor;
          AppArea.vrOpacity = vrAreaOpacity/100;
        } catch (e) {
          console.log(e);
        }   
      }
    
      function resetMap() {
        if (appArea != null) {
          appArea.del();
        }
        appArea = null;
        // Reset stat display
        document.getElementById("num-acres").value = 0;
        document.getElementById("num-bugs").value = 0;
        fileInput.value = null;
        map.data.forEach(function(feature) {
          map.data.remove(feature);
        });
      }
    
      function showAlert(json) {
        let message = JSON.parse(json);
        if (message.alertMessage === "Success") {
          toastr.success("Request Complete!");
        } else if (message.alertMessage === "invalid") {
          toastr.warning("Please Fill Out the Map Application Area.");
        } else {
          toastr.error("Request Failed. Please Try Again.");
        }
      }
    
      function showTip(id) {
        let header = "";
        let text = "";
        switch (id) {
          case "application-date":
            header = "Application Date";
            text = "Enter a preferred date in which the job will take place";
            break;
          case "corrected-acreage":
            header = "Corrected Acreage";
            text =
              "If exact field acreage is known, this number will be used in place of the estimate above." +
              "<br>Note: if this number is given, variable rate areas and hazard areas will not be incorporated into initial bug estimates. Map data will still be sent";
            break;
          case "crop":
            header = "Crop Type";
            text = "The crop(s) contained in the field specified";
            break;
          case "notes":
            header = "Notes";
            text = "Enter any additional information desired";
            break;
          case "operator":
            header = "Preferred Operator";
            text = "Enter the name of a preferred Parabug operator, if desired";
            break;
          case "row-spacing":
            header = "Row Spacing";
            text =
              "The spacing, in feet, between each row of crops in the field specified";
            break;
          default:
            text = "tip not found";
            return;
            break;
        }
    
        modal.style.display = "block";
        document.getElementById("modal-header").innerHTML = header;
        document.getElementById("modal-body").innerHTML = text;
    
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
          if (event.target == modal) {
            modal.style.display = "none";
          }
        };
      }
    
      function toggleAdvancedOptions() {
        let controlTab = document.getElementById("advanced-options-control-tab");
        let btnText = document.getElementById("adv-btn-txt");
        if (controlTab.display === "none") {
          controlTab.display = "inline-block";
          btnText.innerHTML = "Close";
        } else {
          controlTab.display = "none";
          btnText.innerHTML = "Advanced";
        }
      }
    
      function updateStats() {
        try {
          if (appArea != null) {
            // Update stat display
            let acres = appArea.getAdjustedArea();
            acres = round(acres, 3);
            document.getElementById("num-acres").value = acres;
            let bpa = document.getElementById("num-bugs-per-acre").value;
            let vr = document.getElementById("variable-rate").value;
            let totalBugs = appArea.getTotalBugs(bpa, vr);
    
            if (document.getElementById("add-bug-toggle").checked) {
              let bpa2 = document.getElementById("num-bugs-per-acre2").value;
              let vr2 = document.getElementById("variable-rate2").value;
              totalBugs += appArea.getTotalBugs(bpa2, vr2);
            }
    
            document.getElementById("num-bugs").value = round(totalBugs, 0);
          } else {
            document.getElementById("num-acres").value = 0;
            document.getElementById("num-bugs").value = 0;
          }
        } catch (e) {
          document.getElementById("num-acres").value = 0;
          document.getElementById("num-bugs").value = 0;
        }
      }
    
      function validate() {
        if (appArea == null) {
          console.log("App area was null");
          return false;
        }
        if (!appArea.validateAndFix()) {
          appArea == null;
          return false;
        }
        return true;
      }
    
    
      /* EVENT LISTENERS */
      document.getElementById("modal-close").addEventListener("click", function(event) {
        modal.style.display = "none";
      });
    
      bugsPerAcre.addEventListener("change", updateStats);
      bugsPerAcre.addEventListener("paste", updateStats);
      bugsPerAcre.addEventListener("input", updateStats);
      bugsPerAcre2.addEventListener("change", updateStats);
      bugsPerAcre2.addEventListener("paste", updateStats);
      bugsPerAcre2.addEventListener("input", updateStats);
      percentMultiplier.addEventListener("change", updateStats);
      percentMultiplier.addEventListener("paste", updateStats);
      percentMultiplier.addEventListener("input", updateStats);
      percentMultiplier2.addEventListener("change", updateStats);
      percentMultiplier2.addEventListener("paste", updateStats);
      percentMultiplier2.addEventListener("input", updateStats);
    
      document.getElementById("advanced-options-button").addEventListener("click", function(event) {
        let controls = document.getElementById("advanced-options-controls");
        let settingsButton = document.getElementById("advanced-options-button");
        if (controls.style.display === "none") {
          controls.style.display = "block";
          settingsButton.style.marginRight = "0px";
        } else {
          controls.style.display = "none";
          settingsButton.style.marginRight = "12px";
        }
      });
    
      document.getElementById("app-area-opacity").addEventListener("input", function(event) {
        document.getElementById("app-area-opacity-display").innerHTML = this.value + "%";
      });
      document.getElementById("hazard-area-opacity").addEventListener("input", function(event) {
        document.getElementById("hazard-area-opacity-display").innerHTML = this.value + "%";
      });
      document.getElementById("vr-area-opacity").addEventListener("input", function(event) {
        document.getElementById("vr-area-opacity-display").innerHTML = this.value + "%";
      });
      // document.getElementById("overlay-opacity").addEventListener("input", function(event) {
      //   document.getElementById("overlay-opacity-display").innerHTML = this.value + "%";
      // });
    
      toastr.options.positionClass = "toast-top-center";
      document.getElementById("additional-info").addEventListener("submit", function(event) {
        if (validate()) {
          //toastr.optionsOverride({progressBar: 'true'});
          toastr.info("Processing...");
          event.preventDefault();
    
          // Create form data object to easily get form values
          let formData = new FormData(document.getElementById("additional-info"));
          let applicationArea = appArea.toEasyFormat();
          let data = {
            // Map Data
            appArea: applicationArea,
            appAcres: appArea.getArea(),
            hazardAcres: appArea.getHazardArea(),
            vraAcres: appArea.getVRAArea(),
            bugName: formData.get("bug-name"),
            bugsPerAcre: formData.get("bugs-per-acre"),
            variableRate: formData.get("variable-rate"),
            numBugs: formData.get("num-bugs"),
            // User Information Input
            contactName: formData.get("contact_name"),
            contactPhone: formData.get("contact_phone"),
            contactEmail: formData.get("contact_email"),
            billingAddress: formData.get("billing_address"),
            // Application Area Input
            crop: formData.get("crop"),
            rowSpacing: formData.get("row_spacing"),
            ranchName: formData.get("ranch-name"),
            correctedAcreage: formData.get("corrected-acreage"),
            // Preferences Input
            applicationDate: formData.get("application-date"),
            operator: formData.get("operator"),
            notes: formData.get("notes")
          };
          if (document.getElementById("add-bug-toggle").checked) {
            data.bugName2 = formData.get("bug-name2");
            data.bugsPerAcre2 = formData.get("bugs-per-acre2");
            data.variableRate2 = formData.get("variable-rate2");
          }
    
          // Ajax request
          let xhttp = new XMLHttpRequest();
          xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
              let message = this.responseText;
              showAlert(message);
            }
          };
          xhttp.open("POST", "/", true);
          xhttp.setRequestHeader(
            "Content-Type",
            "application/json; charset=UTF-8"
          );
          xhttp.send(JSON.stringify(data));
        } else {
          event.preventDefault();
          console.log("Did not submit");
        }
      });
      
      document.getElementById("mobile-mode").addEventListener("click", function() {
        if (this.checked) {
          drawingManager.setOptions({ drawingMode: null });
          centerMarker.setPosition(map.getCenter());
          centerMarker.setMap(map);
          document.getElementById("mobile-options-div").style.display =
            "inline-block";
        } else {
          drawToggle(drawModeControl.current);
          centerMarker.setMap(null);
          document.getElementById("mobile-options-div").style.display = "none";
        }
      });
    
      document.getElementById("add-bug-toggle").addEventListener("click", function() {
          updateStats();
          if (this.checked) {
            document.getElementById("add-bug-display").style.display =
              "inline-block";
          } else {
            document.getElementById("add-bug-display").style.display = "none";
          }
        });
    </script>
  </body>
  
</html>